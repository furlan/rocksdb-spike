---
applyTo: "**"
---
# Copilot Agent 

This file provides guidance to Copilot Agent when working with code in this repository.

## Overview

Edifice Blackwell is an AI assistant, providing access to the data generated by automation equipments in a house using natural language. This data is accessible through an API using GraphQL.

## Architecture Overview

### Technology Stack

- **Console application**: .Net Core 9.0 using C#
- **Semantic Kernel**: to orchestrate Azure AI calls.
- **Handlebars**: for prompting manager
- **Structure Outputs**: to generate the GraphQL query
- **Azure AI**: LLM implementation
    - Azure AI endpoint: https://ff-openai-gpt-4.openai.azure.com/
    - Azure AI model id: gpt-4-0125-Preview
    - Azure API Key will be provided using environment variable

## Project Structure Overview

- Documentation files in root directory

# Requirements

Create the application in separated phases. The coming phases instructions will be provided in the future.

## Phase 1 - GraphQL query filtering by asset location and or type of operational data

âœ… **Phase 1 Completed** - GraphQL query filtering by asset location and or type of operational data

Create a Console application in Core .NET using C# that interact with the user. The user will enter the prompt. The application needs to undestand the user intent and generate the appropriated GraphQL query.

For this phase, the application just need to extract the intention, the filters values: asset location and type of the operation.

The expected operational data types are: alarm, notification, and utilization. Other words the user can use for "utilization" are "sensors readings", "actual temperature".

The location, are the typical location inside the house: living room, kitchen, family room, dorms, bathroom, etc.

The application will use Semantic Kernel to make the calls to the Azure AI services. You need to use Handlebars to manage the prompts, which needs to be saved in the appropriated folder in YAML format. Also, to make the process more deterministic, the application must uses Structure Outputs.

The GraphQL query to be generated, will be submitted to a GraphQL server API, which will be defined in the next phase. For this phase, just generate the GraphQL query and show as the output in the console.

The GrapQL query will follow the structure below:

```
query {
      asset(location: <<location filter extracted from the user prompt>>) {
        type(name: <<operational data filter extracted from the user prompt>> ) {
          name
          streams {
            id
            name
            uom
            assetId
            values {
              key
              value
            }
          }
        }
      }
    }
```

For example, consider the following prompt from the user: "List the alarms for living room". 
Location identified: "living room", operational data name identified: "alarm"
This is the expected query:

```
query {
    asset(location: "Living Room") {
    type(name: "alarm") {
        name
        streams {
        id
        name
        uom
        assetId
        values {
            key
            value
        }
        }
    }
    }
} 
```
If the user did not provide any information about the location, do not use location as filter.

If the user did not provide any information about operational data, do not use it as the name of the type filter.

For that phase, the application will ignore anything that it is not related with location and operational data.

Document the application in the README file.

# Project general coding standards

## Naming Conventions
- Project name should be EdificeBlackwell (the console app was already created)
- Use camelCase for variables, functions, and methods
- Prefix private class members with underscore (_)
- Use ALL_CAPS for constants

## Design Principles and Best Practices

- **SOLID Principles**
  1. Single Responsibility Principle
  2. Open/Closed Principle  
  3. Liskov Substitution Principle  
  4. Interface Segregation Principle  
  5. Dependency Inversion Principle

- **DRY (Don't Repeat Yourself):**
Avoid code duplication by abstracting common functionality into reusable functions, classes, interfaces, and factories.

## Code Structure

- Follow the standard code structure for .NET C#.

## Development Considerations

- When using the Terminal to test anything, always redirect stdout and stderr to a file and then read the file. Delete the file after reading it. This ensures that you can see the output of your commands, as there is currently a bug in VSCode. Please cat the file so I can see the output as well.
- Use environment variables for configuration (e.g., API keys)
- Ensure that sensitive information is not hardcoded in the codebase
- When creating new files, consider whether there should be any changes to the `.gitignore` file, especially for logs, temporary files, or build artifacts
- As you write code, make sure that you create or update the [README.md](../../../README.md). Create a separated session for Edifice Blackwell application. This file serves as the main documentation for the project and should always reflect the current state of the application.

## Development validation

- When testing features, if you need to run the development server, check if it's already running before starting it again
- Use full paths when running commands instead of relative paths to avoid working in the wrong directory
- For UI testing, please do not test yourself, but instead ask me to test it. Provide details on what you'd like me to test, including specific actions to take and expected outcomes. I will then run the tests and provide feedback.
- All files that you generate for testing should go into the system temp directory, which is `/tmp` on Linux. This ensures that temporary files do not clutter the project directory.

## Error Handling
- Use try/catch blocks for async operations
- Always log errors with contextual information